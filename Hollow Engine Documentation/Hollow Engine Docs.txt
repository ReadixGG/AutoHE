Hollow engine - майнкрафт мод который позволяет создавать майнкрафт сюжеты
Если вы создаете что-то на его основе, то как его создатель прошу указать "Основано на Hollow Engine"

Welcome
to documentation of HollowEngine!

Welcome

This documentation should teach you basics of HollowEngine.

If after reading you don't understand anything. Don`t try again.

Before start
We recommend to learn Kotlin.

Learn it`s structure and basic functions!

!!!WARNING!!!
All documentation written by _BENDY659_ и uertyk_ !

If you found somewhere mistakes, write them on offical Discord server!

Do not disturb other documentation developers, because they may not be involved in this.

Зависимости мода HollowEngine
Просто установить 1 мод и думать что всё будет окей - неверное утверждение!

forge-crush

Вам разве не показалось странным, что такой БОЛЬШОЙ мод весит как-то мало?


График зависимостей​
Зависимости мода HollowEngine в виде графика
Требует

Требует

Требует

Требует

Требует

HollowEngine

HollowCore

Kotlin For Forge

Kotlin Scripts


по поводу KotlinScripts
⚠️ Скачивать нужно полную версию, без таких тегов как: [no-compiler, lite, original, и т.д.] ⚠️


Новая директория
После первого запуска мода,

logo

hollowengine

в корне игры появляется новая папочка с названием hollowengine


О директориях​

О директориях
Описание
Ассеты
Данные
Пути камеры
Реплеи игрока
Скрипты
Измерение рассказчика
icon

Имя директории: Неизвестно.
Описание директории: Выбери одну из директорий выше!

СТОЯТЬ!!!
Если в вашей папке hollowengine не появились эти папки, то не нужно бежать со слезами лететь в канал #помощь и там писал что "У меня нету этих папок", не все они Автоматически появляются и большинство из них вам нужно создать самому!

Имя директории: assets.
Описание директории: Данная директория предназначена для хранение ресурсов (модели, текстуры, звуки и т.д.).

Имя директории: data.
Описание директории: Данная директория предназначена для хранение данных (таблица лута, крафты и т.д.).

Имя директории: camera.
Описание директории: В данной директории хранятся пути для движения камеры.

Имя директории: replays.
Описание директории: В данной директории хранятся все реплеи (записи) движения и действий игркоа.

Имя директории: scripts.
Описание директории: В данной директории хранятся все ваши скрипты.

Имя директории: storyteller_world.
Описание директории: В данной директории хранится отдельный мир мода.

Edit this page
Last updated on May 6, 2025 by algorithmlx
Previous
Зависимости `HollowEngine`
Next
/Команды


Виды скриптов
Для удобства и понимания, существует несколько видов скриптов

scripts-type


А именно
Сюжетные события
Script - StoryEvents

Расширение у файлов должно быть .se.kts (пример: story.se.kts)

Является основным видом скрипта для ваших сюжетов.

В нём происходит вся логика и построение.


Контент
Script - StoryEvents

Расширение у файлов должно быть .content.kts (пример: crafting-table.content.kts)

Является дополнительным видом скрипта для ваших сюжетов.

С помощью данного вида, вы можете: добавить/изменить/удалить рецепты крафтов.


Модификации
Script - StoryEvents

Расширение у файлов должно быть .mod.kts (пример: katana.mod.kts)

Является дополнительным видом скрипта для ваших сюжетов.

С помощью данного вида, вы можете писать свои полноценные моды, без необходимости создавать главный класс, регистрации классов как при написании обычных модов.


Библиотека (Library)
Расширение у файлов должно быть .kts (пример: distanceMath.kts)

Этот вид скрипта не является ни основным ни дополнительным.

Это тип файла называется "Скрипты Котлина (Kotlin Scripts)". Это базовый формат файла языка Kotlin.

Сам по себе не несёт никакой функционал. Вы можете записывать в такие скрипты всякие вычисления и не только.

Ресурсы (или же Assets)
Просто кинуть файл, в папку assets - это глупая ошибка.

resources

Повторюсь: Папка Assets работает как и Ресурс паки, но без необходимости создавать под это дело архив и файл pack.mcmeta.

Работает это по принципу ResourceLocation, так думаю с него и стоит начать объяснение.



Папка assets
Все ресурсы размещаются в отдельной папке assets

Об ResourceLocation...​
ResourceLocation
Через ResourceLocation мы указываем путь по директориям, откуда брать тот или иной файл.

!!! ОСТОРОЖНО !!!
Обзывать файлы и папки как вам хочется — не выйдет, для этого есть строгие правила.

"В ваших именах папок и файлов могут входить только следующие символы":

Все буквы Английского алфавита от a до z !ТОЛЬКО НИЖНЕГО РЕГИСТРА!
Все цифры от 0 до 9
и допустимый символ _

Кратно записывают так: [a-z, 0-9, _]


Как работает 'ResourceLocation'


Ресурсы​
Ресурсы
Хранить ресурсы вы можете как душе вам угодно.

Ниже буду приведены поддерживаемые форматы (если таковы есть) и то как размещать ресурсы, если вы не сильно в этом разбираетесь.




Модели​
Модели
Список поддерживаемых форматов:

glTF [.gltf]
GLB [.glb]

Я не понимаю где размещать модели

Текстуры​
Текстуры
Список поддерживаемых текстур:

Png [.png]
Gif [.gif]

Я не понимаю где размещать текстуры

Звуки​
Звуки
Список поддерживаемых звуков:

Ogg [.ogg]

Все звуки хранятся строго в папке assets/<mod_id>/sounds.

Тут всё не так просто как кажется.

Ручная регистрация

Автоматическая регистрация
ВНИМАНИЕ
После изменения что-то в ресурсах - требуется перезагрузка ресурсов на комбинацию клавиш
F3 + T!

Измерение рассказчика
Для вас становится доступным "Новое измерение" доступ, к которому — вы можете получить буквально из любого мира.

storyteller-world

Для вас нет ограничений, ведь вам предстоит создать там мир!


Как попасть в это измерение​
Нужно лишь выполнить несколько не сложных действий, а именно:

Предмет-телепорт
Взять в основную руку данный предмет

storyteller-teleport-item

item-desc

После держа предмет в руке - кликнуть по любому блоку ПКМ, и вы окажитесь посреди пустоты, стоя на одном единственном алмазном блоке...



image

Специальные типы переменных
title

Ты конечно можешь использовать обычный val

val staticVariable: String = "Эта переменая - не изменяемая"
Но если нужно сохранить денные этой переменной, то оно не сработает, т.к. после перезапуска скрипта - значение переменной сбросится. На такой случай есть 3 специальных типа переменных:

// Переменаня, которая сохраняет значение пока скрипт работает //
// Не совместим с var //
val lazyVariable by lazy { ... }

// Переменная, которая имеет память и сохраняет её до выхода из мира //
var runtimeVariable by runtime { ... }

// Переменная, которая имеет гига-память //
// т.е. даже после перезахода в игру - она сохранит своё значение //
val saveableVariable by saveable { ... }
И уже в { ...} вы можете записать как и обычное значение: var health by lazy {10}, так и целые кусочки кода:

var moneys by saveable {
  If({ me().health >= 10f }) {
    620
  } Else {
    0
  }
}

Да, есть ещё конечно и var - но работать так как обычно он должен работать - не будет в скриптах. Именно по этому для скриптов есть универсальный метод next:

next {
  код, который должен будет выполнятся во время работы скрипта, а не во время
  его компиляции.
}
Пример
var dynamicVariable = "Это динамическая переменная"

next { dynamicVariable = "Теперь тут хранится совершенно другое"}

next {
  val privateVariable = 10 // До неё не достучаться вне next

  dynamicVariable = "Здесь есть число $privateVariable"
}

Создание
Первая, "живая", функциональная сущность

nip-create


Шаблон​
Здесь указаны все возможные настройки, которые есть при создании НИПа

Не копируйте просто на отвали. Лучше поймите как написать
val npcID by NPCEntity.creating {
  // Базовые параметры
  name = "НИП"
  model = "mod_id:path/to/models.gltf"
  pos = pos(0.5, 64.0, 0.5)
  
  // Дополнительные параметры
  
  textures["gltf_models_model_layer_0_gltf"] =
    "mod_id:path/to/texture.png"
    // или
    skin("Hlebobulka_")
  
  animations[AnimationType.IDLE] = "idleDance"
  attributes = Attributes(
    "generic.movement_speed" to 2f
  )
  size = 1f to 2f
  showName = false
  transform = Transform(
    tX = 1f, tY = 1f, tZ = 1f,
    rX = 0f, rY = 180f, rZ = 0f,
    sX = 1f, sY = 1f, sZ = 1f
  )
  swirchHeadRot = false
  world = "overworld"
  rotation = vec(-45f, 15f)
  subModel = SubModel(
    model = "mod_id:path/to/model.gltf",
    layers = mutableListOf(
      AnimationLayer(
        animation = "animationName",
        layerMode = LayerMode.ADD,
        playMode = PlayMode.LOOPED,
        speed = 1f
      )
    )
  )
}

До настройки
Иногда может понадобиться, изменить какие-то параметры НИПа в нужный момент.

vitalik-crash

В моде есть реализация этого.


Метод​
Вся такие до настройки происходят внутри метода

<npcID>.configure {
  ... // Т.е. здесь!
}

Какие параметры поддерживает​
Поддерживаются все параметры, что были При создании НИПа, но кроме name. Для такого предусмотрен отдельный метод ниже.

npdID - это переменная НИПа (просто npdID его обозвал какой-то дурак). Ты же там писал типа такого: val npc by NPCEntity... где npc - это и есть его npcID.


Вписываются довольно просто:

Пример
<npcID>.configure{
  model = "hc:models/entity/hilda_regular.glb"
}


Дополнительные возможности​
Помимо тех, которые можно вписать в сам метод configure, есть ещё и отдельные, которые независимы от этого метода.

Такими являются:

Возможность менять иня НИПа
<npcID>.name = "Новый НИП"
Возможность сделать Бессмертным
<npcID>.invulnerable = true
Возможность менять режим колизии с НИПом
<npcID>.hitboxMode = HitboxMode.BLOCKING


Действия
Возможность управлять вашими НИПами

Двигаться​
Двигаться
До позиции
До игрока
До Другого НИПа
До сущности
Бесконечно

Стандартый метод может работать криво. Используйте из пака HollowEngine: Fixer на дискорд сервере в канале #scripting-templates!

<npcID> moveTo { pos(x, y, z) }
НИП будет идти до Указанных координат в pos(x, y, z).

Пример
npc moveTo { pos(13, 65, 235) }

Двигаться​
Двигаться
До позиции
До игрока
До Другого НИПа
До сущности
Бесконечно

<npcID> moveTo { <player> }
НИП будет идти до Указанного игрока.

Пример
val players by server.players

npc moveTo { players.first() }

// ИЛИ //

val me by server.players.filter { it.name.string == "_BENDY659_" }

npc moveTo { me }

Двигаться​
Двигаться
До позиции
До игрока
До Другого НИПа
До сущности
Бесконечно

<npcID> moveTo <npcID>
НИП будет идти до Указанных НИПа .

Пример
val kolya by NPCEntity.creating {...}

npc moveTo kolya
Беда
Есть шанс что НИП скорее всего не до конца дойдёт до НИПа, и из-за этого скрипт никуда дальше не пойдёт.

Можно избежать этого, если передвижение НИПа сделать через:

Пример
val kolya by NPCEntity.creating {...}

npc moveTo { kolya().position() }

Двигаться​
Двигаться
До позиции
До игрока
До Другого НИПа
До сущности
Бесконечно

Тема для прошаренных
<npcID> moveTo <Entity>
// или
<npcID> moveTo { <Entity> }
НИП может идти до конкретной сущности.

Двигаться​
Двигаться
До позиции
До игрока
До Другого НИПа
До сущности
Бесконечно

Есть за место moveTo написать moveAlwaysTo, то НИП будет двигаться до указанного - Бесконечно.

Для того чтобы остановить выполнение, нужно прописать:

<npdID>.stopMoveAlways()
Пример
npc moveAlwaysTo { player().first() }

npc.stopMoveAlways()

Бегать

НИП так же может бегать. Бег меняет скорость передвижения.

<npcID>.isRunning = true // Вкл. режим бега

<npcID>.isRunning = false // Выкл. режим бега. По умолча

Смотреть​
Смотреть
На позицию
На игрока
На Другого НИПа
На сущность
Бесконечно

<npcID> lookAt { pos(x, y, z) }
НИП будет смотреть на Указанные координаты в pos(x, y, z).

Пример
npc lookAt { pos(-361, 83, 23) }

Смотреть​
Смотреть
На позицию
На игрока
На Другого НИПа
На сущность
Бесконечно

<npcID> lookAt { <player> }
НИП будет смотреть на Определённого игрока.

Пример
npc lookAt { player().first() }

Смотреть​
Смотреть
На позицию
На игрока
На Другого НИПа
На сущность
Бесконечно

<npcID> lookAt <npcID>
НИП будет смотреть на Указанного НИПа.

Пример
val hollowNpc by NPCEntity.creating {...}

npc lookAt hollowNpc

Смотреть​
Смотреть
На позицию
На игрока
На Другого НИПа
На сущность
Бесконечно

<npcID>.lookAtEntityType { "<entityID>" }
Здесь вы можете указать уже именно ID сущности.
Тогда НИП будет смотреть на ту, которая к нему ближе.

Пример
npc.lookAtEntityType { "dog" }

Смотреть​
Смотреть
На позицию
На игрока
На Другого НИПа
На сущность
Бесконечно

<npcID> lookAlwaysAt { <target> }
Есть за место lookAt написать alwaysLookAt, то НИП будет смотреть на указанное - Бесконечно.

Для того чтобы остановить выполнение, нужно прописать:

<npcID>.stopLookAlways()
Пример
npc lookAlwaysAt { player().first() }

npc.stopLookAlways()

Телепорт​
Телепорт

Частицы в подписку не входят!

<npcID> tpTo {
  pos = pos(x, y, z)
  vec = vec(pitch, yaw)
  world = "<dimentionID>"
}
Телепортирует НИПа на указанные координаты и в указанный мир (опционально).

pos(x, y, z) - Координаты, куда нужно телепортировать.
vec(pitch, yaw) - Куда будет смотреть НИП после телепорта.
dimentionID - Мир, в который нужно телепортировать НИПа. Если оно не указано - берётся тот мир, в котором находится НИП в данный момент.

Взаимодействие с миром​

Сломать блок​
Сломать блок

Кирки в подписку не входят!

Стандартый метод может работать криво. Используйте из пака HollowEngine: Fixer на дискорд сервере в канале #scripting-templates!

<npcID> destroyBlock { pos(x, y, z) }
Сломать блок на указанных координатах.

НИП подойдёт к заданным координатам как можно ближе и после сломает блок.

Пример
npc destroyBlock { pos(10, 35, 221) }

заимодейтсвие с блоком​
Взаимодействие с блоком

Игра с ИИ в подписку не входит!

<npcID> useBlock { pos(x, y, z) }
Взаимодействовать с блоком на указанных координатах.

НИП подойдёт к заданным координатам как можно ближе и повзаимодействует с блоком.

Пример
npc useBlock { pos(19, 73. 94) }

Атаковать​
Атаковать цель

Мита в подписку не входит!

<npcID> setTarget { <target> }
НИП будет атаковать цель до последнего, пока цель не умрёт.

Целью может быть:

Игрок - Нужно за место <target> указать
Определённого игрока.
Другой НИП - Нужно за место <target> указать npcID другого НИПа в виде лямбы.
npcId setTarget { otheNpcId() }
Сущность - Нужно за место <target> указать
LivingEntity (Для прошаренных).
Перестать атаковать цель
<npcID>.clearTarget()
Пример
val players by server.players

npc setTarget { player()[0] }

npc clearTarget()
Имейте в виду что данный метод не ждёт когда цель - умрёт. Скрипт продолжится дальше. Если вам нужно ждать, то используйте один из триггеров.

Анимации
Танцуй как хочешь

animations

Покажи всем свои навыки акробатики


Режимы воспроизведения анимации​
Есть 4 режима. Все они задаются в классе PlayType

Режимы воспроизведения анимации
Одноразово
Цикл
Замереть
Реверс
playOnce

Анимация воспроизводится 1 раз после её вызова. Останавливается автоматически как только анимация закончилась.

PlayType.ONCE

Режимы воспроизведения анимации
Одноразово
Цикл
Замереть
Реверс
playLooped

Анимация воспроизводится в цикле (бесконечно). Останавливается вручную.

PlayType.LOOPED

Режимы воспроизведения анимации
Одноразово
Цикл
Замереть
Реверс
playLooped

Анимация воспроизводится 1 раз после выова, после замирает на последнем карде. Останавливается вручную.

PlayType.LAST_FRAME

Режимы воспроизведения анимации
Одноразово
Цикл
Замереть
Реверс
playLooped

Анимация воспроизводится в цикле (бесконечно) туда-сюда. Останавливается вручную.

PlayType.REVERSED

Воспроизведение​
Можно воспроизвести анимации 2-мя разными способами


Способ #1
Самый простой способ, не требующий заморочек.

Запустить...
1 раз
В цикле
И замереть
<npcID> playOnce {"<animation_name>"}
Данный метод запустит указанную анимацию всего 1 раз.

Пример
npc playOnce {"levitation"}
При таком способе вам будет достаточно указать лишь название анимации.

Воспроизведение​
Можно воспроизвести анимации 2-мя разными способами


Способ #1
Самый простой способ, не требующий заморочек.

Запустить...
1 раз
В цикле
И замереть
<npcID> playLooped {"<animation_name>"}
Данный метод запустит указанную анимацию в цикле (т.е. бесконечно будет воспроизводится)

Пример
npc playLooped {"dance5"}
При таком способе вам будет достаточно указать лишь название анимации.

Воспроизведение​
Можно воспроизвести анимации 2-мя разными способами


Способ #1
Самый простой способ, не требующий заморочек.

Запустить...
1 раз
В цикле
И замереть
<npcID> playFreeze {"<animation_name>"}
Данный метод запустит указанную анимацию всего 1 раз и после замрёт на последнем кадре.

Пример
npc playFreeze {"hug"}
При таком способе вам будет достаточно указать лишь название анимации.



Остановить воспроизведение​

Остановить воспроизведение
Для остановки воспроизведения анимации есть метод

<npcID> stop {"animation_name"}
Данный метод принудительно останавливает анимацию.

пример
npc stop {"dance5"}

Группы и Групповые действия
Много НИПов в одной группе

groups

На первый-второй - рассчитайсь!


Создание группы​

Создание группы
Для создания группы где может быть 2 и более НИПа

val <groupID> = arrayOf(<npcID0>, <npdID1>, ...)
groupID - это просто перменная, чтобы вы могли обращаться к этой группе.

Так вы создали список НИПов, которые входят в эту группу. Теперь они как одно-целое.



Действия для группы​

Действия для группы
Так можно выдать одно действие всем НИПам, которые находятся в этой группе, сразу всем

<groupID>.forEach { it <action> }
action - Те же действия, что и у обычных НИПов (только не нужно указывать npcID). Действия для НИПов


Имейте в виду
Все заданные действия для НИПов в группе будут выполнятся последовательно. Т.е. как вы их указали в списке изначально - в такое порядке и будут идти.

Задания
Ты должен отдать НИПу то-то

quests

и таких-то количествах


Создание списка заданий

Создание списка заданий
Для создания такого списка, используйтесь методом:

<npcID>.requestItems {
  ... // Список требований
}
Добавления нового требования с список
Чтобы добавить в список новое требование

+item("<itemID>", <count>, "<nbt_tags>")
itemID - id предмета (да ладно, а ты что думал?),
count- количество требуемого предмета,
nbt_tags - NBT-теги предмета. На случай если нужно какой-то определённый предмет с определёнными данными.

И ещё
У вас нет лимитов в количестве требований к заданию. Добавляйте сколько влезет через новую строку.

+item("item_id", 12)
+item("item_id", 16)
... // И так далее
Пример
npc.requestItems {
  +item("wooden_planks", 16)
  +item("st:skint_crystal", 4)
}

Под-модели
Придать любой наряд НИПУ

sub-models

(и PWGood в придачу)


Добавление модели​
Добавление модели
Дополнительную модель ты можешь наложить только либо на кость, либо на группу

subModel["<bone/group>"] = SubModel(
  model = "<path/to/model>", // Модель
  textures["<>textureName>"] = "<path/to/texture>", // Текстура для модели
  layers = mutableListOf( // Анимации
    AnimationLayer(
      animation = "<animationName>", // Название анимации
      layerMode = LayerMode.<TYPE>, // Режим смешивания
      playMode = PlayType.<TYPE>, // Режим воспроизведени
      speed = <Float> // Скорость воспроизведения
    ) // Если нужно запустить несколько анимаций, то пишете через запятую
  ),
  transform = Transform( // Трансформация
    tX = <Float>, tY = <Float>, tZ = <Float>, // Смещение
    rX = <Float>, rY = <Float>, rZ = <Float>, // Поворот
    sX = <Float>, sY = <Float>, sZ = <Float> // Масштаб
  ),
  subModel = SubModel(...) // Под-модель для модели. Тот же синтакс
)
bone/group - Название кости или группы в модели.

Имейте в виду
на одну кость/группу - только 1 модель!



Пустые значения​
Пустые значения
Установить модель без всех значений - нельзя. Так что нужно указать хотя бы значения у параметров - по умолчанию.

layers = ArrayList() // Модель без анимаций
textures = HashMap() // Модель без дополнительных текстур
transform = Transform() // Без трансформации
subModel = HashMap() // Без дополнительной под-модели


Пример​
subModel["Head"] = SubModel(
  "models:decores/tophead_black,gltf", // model
  mutableListOf( // layers
    AnimationLayer(
      animation = "levitation"
      layerMode = LayerMode.ADD
      playMode = PlayType.LOOPED
    )
  ),
  HashMap(), // textures
  Transform(), // transform
  HashMap() // subModel

)

Торговец
Только у нас

trader-0-0

Самые высокие цены!


Создать торговца

Создать торговца
Для создания торговка НИпа - существует метод:

<npcID> addTrade(
  MerchantOffer(
    item("<itemID>", <count>, "<nbtTags>"), // Требуемая вещь #1
    item("<itemID>", <count>, "<nbtTags>"), // Требуемая вещь #2
    item("<itemID>", <count>, "<nbtTags>"), // Продаваемая вещь
    <maxTrades>, // Макс количество торгов
    <xpTrade>, // Количество опыта для прокачки торговца
    <priceMultiple> // Процент скидки
  )
)
Имейте в виду
Если вы хотите добавить ещё трейды, то нужно вызывать метод по новому:

<npcID> addTrade(...) // Трейд #1
<npdID> addTrade(...) // Трейд #2
... // И так далее


Возобновление торгов​

Возобновление торгов
Чтобы возобновить торги, а именно снова иметь возможность торговаться - есть метод

<npcID>.clearTradesUses() // Обнуляет счётчик торгов


Удалить возможность торговли​

info
Так же можно у Торговца НИПа отобрать возможность торговатсья и сделать его снова обычным

<npcID>.clearTrades()

Предметы в руках
Классно что-то держать в руках

npc_hand-item

Особенно когда это деньги или мешок с деньгами


Отображение предмета в руке​

Не отображается предмет
Есть после выдачи предмета в руки НИПу предмет не отображается в руках, то жмите на кнопку ниже.


Предмет не отображается [Инструкция]


Действие с предметами​\
Действие с предметами
Выдать
Убрать
Выбросить
Выдать предмет в руки НИПа
/* Выдать предмет в Левую руку */
<npcID> giveLeftHand { item("<itemID>") }

/* Выдать предмет в Правую руку */
<npcID> giveRightHand { item("<itemID>") }
Пример
npc giveLeftHand { item("me:chiken") }
npc giveRightHand { item("me:cheese") }
Действие с предметами
Выдать
Убрать
Выбросить
Убрать предмет из рук НИПа
/* Убрать предмет в Левую руку */
<npcID> giveLeftHand { null }

/* Убрать предмет в Правую руку */
<npcID> giveRightHand { null }
Пример
npc giveLeftHand { null }
npc giveRightHand { null }
Действие с предметами
Выдать
Убрать
Выбросить
Выбросить предмет от лица НИПа
<npcID> dropItem { item("<itemID>") }
Пример
npc dropItem { item("me:pineapple") }

Удалить
Все неудачи можно скрыть

npc-remove

просто дизентегрируя их из мира


Удалить
Просто удалить его из мира

<npdID>.despawn()
Пример
npc.despawn()
и всё.



диалоги: основная функция в разработке, поэтому используйте такую строчку для сообщения в чат:
execute{"tellraw @a [\"\",{ \"text \": \"[Имя нпс/персонажа/героя, в скобках квадратных] \", \"color \": \"#66CDAA \"},{ \"text \": \" Текст \", \"color \": \"white \"}]"}



Получить игрока
Теперь любого игрока

players

можно затащить в сюжет


Получить игрока(-ов)​

Получить всех игроков на сервере
Всех
Для получения всех игроков, которые находятся на сервере (в мире) - используйте эту переменную

val <players> by server.players

Получить конкретных(-ого) игроков(-а)
Через фильтр
Для получения определённых(-ого) игроков(-а) можно использовать фильтр

val <players> by server.players.filter { <filter> }
Фильтров много, но расскажу про самый простой:

Получить игрока с определённым ником:
it.name.string == "<playerNick>"
По уровню [Game-Stage]
Требуется дополнительный мод
Данный фильтр работает только при установленном моде GameStage!


Для получения списка игроков, который находятся на указаном уровне

val <players> by server.players.filter { it.hasStage("<Level>") }

Первый в списке
Можно и обойтись простым методом, где просто из всех игроков можно получить только первого игрока

val <players> by server.players
val <player> = players().first()
// или //
val <player> = players()[index]
// где index - это индекс из списка (список, потому что server.player возвращает список) //
Обрати внимание!
Если из <players> - мы получали список игроков, состоящий из н кол-ва игроков (т.е. массив), то после <player> (первого варианта) - мы всё равно получаем тоже список, только в списке всего 1 элемент.

По этому если вам нужно получить именно конкретно игрока (как пример для цели НИПа) нужно использовать <player> (второго варианта). Только через него можно получить именно игрока, а не массив.

Модель игрока
Менять модель игрока так же

no-title

как и у НИПов


Установить модель​

Установить модель
Установка модели происходит так же, как и у НИПов, в методе configure

<player>.configure {
  model = "<path/to/model>" // Путь к модели
  
  // Если голова поворачивается не правильно
  switchHeadRot = true
}
Пример
me.configure {
  model = "my_mod:models/player/best_model.gltf"
}


Сбросить модель​

сбросить модель
Если же нужно вернуть стандартную модель игрока, то за место пути, укажите значение %NO_MODEL%

player.configure {
  model = "%NO_MODEL%"
}


Действия
Управлять игроками(-ом)

no-title


Телепортировать​
Телепортировать
Телепортировать игрока в определённый мир и в определённую точку

<players>.tpTo {
  pos = pos(x, y, z) // Позиция по оси X, Y и Z
  vec = vec(<pitch>, <yaw>) // Поворот по оси X (влево-вправо) и Y (вверх-вниз)
  world = "<dimension_id>" // ID измерения | По умолчанию: overworld
}
Пример
players.tpTo {
  pos = pos(52, 85, -251)
  vec = vec(-90f, 40f)
  world = "hollowengine:storyteller_world"
}


Атрибуты​
Атрибуты
Так же можно и изменять некоторые настройки атрибутов

<player>.modify {
  
  /* Здоровье */
  
  setHealt(<Float>) // Установить количество здоровья
  setMaxHealt(<Float>) // Установить Маас количество здоровья
  addHealt(<Float>) // Добавить количество здоровья к нынешнему
  
  /* Защита */
  
  equipHelmet( item("<item_id_helmet") ) // Одеть шлем
  equipChestplate( item("<item_id_chestplate>") ) // Одеть нагрудник
  equipLeggings( item("<item_id_leggings") ) // Одеть поножи
  equipBoots( item("<item_id_boots") ) // Одеть ботинки
  /*
   * Если нужно снять броню, то за место item() укажите:
   * - null
   * или
   * - item("air")
  */
}
Пример
me.modify {
  setHealt(20F)
  setMaxHealt(100F)
  addHealt(50f)
  
  equipHelmet( null )
  equipChestplate( item("netherite_chestplate") )
  equipLeggings( item("iron_leggigns") )
  equipBoots( item("leather_boots") )
}

Работа с инвентарём
Мы все любим чистоту в инвентаре

player-inventory

но мы замусорим просто


Сохранение
<players>.saveInventory()
Одно место
Сохранить вы можете только 1 раз. После просто сохранение будет перезаписываться!


Загрузка
<players>.loadInventory()

Очистка :D
<players>.clearInventory()

Пост-процессинг
Искажения, размытия и свечение, всё как ты захочешь

post-proccessing

Или просто проведи опыт по "Выжиганию глаз" другого человека)


Что такое Пост-процессинг
Это вид эффекта, который накладывается после отрисовки кадра, что-то вроде фильтров.


Использование эффекта​
Использование эффекта
<team> postEffect { PostEffect.<TYPE> }
Типы эффектов, которые уже вшити в мод:

SEPIA - Эффект сепии.
GRAY - Оттенки серого.
SHAKE - Эффект тряски камеры.
VIGNETTE - Виньетка по краям.
BLUR - Размытие.
Пример
player postEffect { PostEffect.BLUR }

Создание своего эффекта​
Создание своего эффекта
val MY_EFFECT = PostEffect.create(path: ResourceLocation)
Пример
val BLOOM = PostEffect.create("my_mod:shaders/post/my_bloom.json")

Управлением временем
Джовардо, или как там в вашем аниме?

no-title

Ладно, не прям, что остановка времени


Контроль​
Контроль
Джовардо, или как там (я не анимешник крч), но типо отдалённо что-то есть схожее...

pauseTime() // Остановить теченеи времени

wait { <time> } // Так можно укзаать на сколько остановить время

resumeTime() // Вернуть теченеи времени
Откуда я знаю по этого ваши Джо-Джо? Спасибо Youtube shorts

Давайте чесно
На деле оно не замораживает теченеи времени (как в новой 1.20 версии игры), а просто останавливает движение солнца.

Триггеры
Ждать определённого действия

NO_TITLE

чтоб потом продолжить работу


Автоматический запуск скрипта​
Автоматический запуск скрипта
Местоположение в скрипте
Данные триггеры должны находится в самом начале скрипта, выше обычных import!

При самом первом входе в мир
@file:EntryPoint
При обычном входе в мир
@file:JoinScript
Запуск этого скрипта, после окончания работы указанного скрипта в параметрах
@file:AfterScript("<path/to/script>")
Цикличный скрипт. После завершения работы - скрипт запустится ещё раз и так по кругу
@file:RepeatableScript


Ожидание конца таймера​
Таймер
Ждёт, пока не пройдёт указанное время.

wait { time }
time - Время, которое должно пройти, чтобы скрипт продолжил свою работу.

Пример
wait { 5.sec }


Ожидание нажатия клавиши​
Нажатие клавиши
Ждёт, пока указанная клавиша не будет нажата.

keybind { Keybind.<KEY> }
KEY - ID клавиши. Клавиши

Пример
keybind { Keybind.H }


Ожидание взаимодействия с НИПом​
Взаимодействие с НИПом
Ждёт, пока любой игрок не по взаимодействует с определённым НИПом.

<npcID>.waitInteract()
Пример
npc.waitInteract()


Ожидание сообщения​
Ожидание сообщения
Ждёт, пока любой игрок не отправит какое-то сообщение в чат.

<players>.input() // Любое сообщение
// или
<players>.input("<text>") // Конкретное сообщение
// или
<players>.input("<arg0>", "<arg1>", ...) // Конкретное сообщение из списка

/*Запись в переменную */
val myValue by <players>.input() // Запишет в переменную содержание сообщение
Пример
val players by server.players

players.input()

players.input("Привет")
players.input("Привет", "Hello")

val meMessage by players.input()


Ожидание позиции​
Ожидание позиции
Ждёт, пока любой из игроков не будет в указанных координатах.

<players>.waitPos {
  pos = pos(x, y, z) // Позиция, где будет ожидатся игрок
  radius = <Double> // Радиус от центра координат pos
  ignoreY = <Boolean> // Игнорирует высоту при вычислении расстояния до точки, при true.
  createIcon = <Boolean> // Если true - будет создана иконка в позиции pos
  icon = "<mod_id>:<path/to/texture>".rl // Не обязательно. Кастомная иконка
  world = "<dimension_id>" // ID измерения
  inverse = <Boolean> // Если true - игрок должен покинуть территорию в этом радиусе
}
Пример
players.waitPos {
  pos = pos(-235, 82, 882)
  radius = 10.5
  ignoreY = true
  createIcon = true
  world = "overworld"
}


Обратное условие​
Обратное условие
Ждёт, пока условие не вернёт false.

await { <Условие> }
Пример
await { npc().isAlive } // Скрипт не продолжит свою работу, пока НИП не умрёт

Логика и Цикл
Если А - это ананас, то Б - это банан

logica

иначе — манго


Условие​
Условие
Стандартные if/else if/else тут работать не будут. Вернее будут, но сработают только во время компиляции вашего скрипта, а не вовремя его работы. Так что на этот случай есть специальные методы.

If({ <Условие> }) {
  ... // Если условие вернуло true
}.Elif({ <Условие> }) {
  ... // Если предыдущее условие вернуло false, а текущее true
} Else {
  ... // Если условие вернуло false
}
Пример
If({ a == 0 }) {
  LOGGER.info("а равно 0")
}.Elif({ a == 1 }) {
  LOGGER.info("а равно 1")
} Else {
  LOGGER.info("а фиг пойми чему равно :(")
}


Цикл​
Цикл
Обычный цикл while тоже не сработает (вы просто заставите компилятор много думать, а он будет есть вашу ОЗУ 🙂)

While({ <Условие> }) {
  ... // Пока условие вернуло true - будут выполняться команды в этом поле
}
Пример
While({  a < 10 }) {
  LOGGER.info("Сейчас a равно: {}", a)
  
  a += 1
}

Запуск скрипта
Запуск скрипта внутри скрипта

NO_TITLE

гениально же


Запуск скрипта
startScript { "<path/to/script>" }
path/to/script - Указывается путь к скрипту от папки scripts, как в команде /hollowengine start-script

startScript { "scripts/my/myModelScript.se.kts" }